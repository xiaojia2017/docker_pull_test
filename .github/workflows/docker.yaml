# ========== 3. 镜像处理核心逻辑（修复后） ==========
- name: Process and Push Images
  run: |
    # 定义目标路径（修复点1：添加调试输出）
    TARGET_PREFIX="${{ env.ALIYUN_REGISTRY }}/${{ env.ALIYUN_NAMESPACE }}/${{ env.ALIYUN_REPO_NAME }}"
    echo "调试信息：TARGET_PREFIX=$TARGET_PREFIX"  # 确保此处输出完整路径

    while IFS= read -r line; do
      [[ -z "$line" ]] || [[ "$line" =~ ^# ]] && continue

      # 提取平台参数（兼容性写法）
      platform_arg=$(echo "$line" | sed -n 's/.*--platform \([^ ]*\).*/\1/p')
      original_line=$(echo "$line" | sed 's/--platform [^ ]*//')

      # 解析原始镜像名称（修复点2：保留原始路径结构）
      src_image=$(echo "$original_line" | awk '{print $NF}' | sed 's/@sha256:.*//')
      
      # 分离镜像名和标签
      image_name=$(echo "$src_image" | awk -F: '{print $1}')
      image_tag=$(echo "$src_image" | awk -F: '{print $2}')
      
      # 转换镜像名称（修复点3：仅替换非法字符，保留斜杠）
      converted_name=$(echo "$image_name" | sed 's|[:@]|-|g')  # 只替换冒号和@
      safe_image_tag=$(echo "$image_tag" | sed 's|[/:@]|-|g')
      
      # 生成最终镜像名称（修复点4：使用标准路径结构）
      final_image="${converted_name}:${safe_image_tag}"  # 使用冒号分隔名称和标签
      
      # 添加平台后缀
      if [ -n "$platform_arg" ]; then
        platform_suffix="-$(echo "$platform_arg" | tr '/' '_')"
        final_image="${converted_name}:${safe_image_tag}${platform_suffix}"
      fi

      # 生成合法目标路径（修复点5：使用完整前缀）
      target_image="${TARGET_PREFIX}:${final_image}"
      echo "调试信息：target_image=$target_image"  # 验证最终路径

      # 执行Docker操作
      docker pull "$src_image"
      docker tag "$src_image" "$target_image"
      docker push "$target_image"
      docker rmi "$src_image" "$target_image" || true

    done < ./images.txt
