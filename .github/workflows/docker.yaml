name: Aliyun Image Push

on:
  workflow_dispatch:  # 允许手动触发工作流
  push:
    branches: [ main ]  # 仅当main分支有推送时触发

env:
  # 使用GitHub Secrets管理敏感信息（安全最佳实践）
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"  # 从Secrets获取仓库地址，避免硬编码
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}/k8s"  # 组合命名空间和仓库路径
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"  # 使用AccessKey ID进行认证
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"  # 使用AccessKey Secret

jobs:
  push-image:
    name: Push to Aliyun
    runs-on: ubuntu-latest  # 使用GitHub托管的Ubuntu环境

    steps:
    # ========== 1. 检出代码（代码库初始化） ==========
    - name: Checkout Code
      uses: actions/checkout@v4  # 官方检出动作，将代码库内容克隆到$GITHUB_WORKSPACE
      # 知识点：必须检出才能访问仓库中的images.txt文件

    # ========== 2. 登录阿里云（认证流程） ==========
    - name: Login to Aliyun
      run: |
        # 使用管道安全传递密码（防止密码泄露到日志）
        echo "${{ env.ALIYUN_REGISTRY_PASSWORD }}" | docker login \
          -u "${{ env.ALIYUN_REGISTRY_USER }}" \  # 指定用户名
          --password-stdin "${{ env.ALIYUN_REGISTRY }}"  # 从环境变量获取仓库地址
      # 知识点：--password-stdin是Docker推荐的安全登录方式

    # ========== 3. 镜像处理核心逻辑（数据转换管道） ==========
    - name: Process and Push Images
      run: |
        # 定义目标镜像前缀（组合仓库地址和命名空间）
        TARGET_PREFIX="${{ env.ALIYUN_REGISTRY }}/${{ env.ALIYUN_NAME_SPACE}}"

        # 逐行读取镜像列表文件（支持包含平台参数）
        while IFS= read -r line; do
          # 跳过空行和注释行（数据清洗）
          [[ -z "$line" ]] || [[ "$line" =~ ^# ]] && continue

          # 提取平台参数（兼容不同grep版本）
          platform_arg=$(echo "$line" | sed -n 's/.*--platform \([^ ]*\).*/\1/p')  # 使用sed替代grep -P
          original_line=$(echo "$line" | sed 's/--platform [^ ]*//')  # 移除平台参数得到原始镜像

          # 解析原始镜像名称（支持含SHA256的格式）
          src_image=$(echo "$original_line" | awk '{print $NF}' | sed 's/@sha256:.*//')  # 去除哈希校验部分
          
          # 分离镜像名和标签（兼容无标签的情况）
          image_name=$(echo "$src_image" | awk -F: '{print $1}')  # 获取镜像名称部分
          image_tag=$(echo "$src_image" | awk -F: '{print $2}')  # 获取标签部分（默认为latest）
          
          # 转换镜像名称（符合阿里云命名规范）
          converted_name=$(echo "$image_name" | sed 's|/|_|g; s|:|-|g')  # 替换非法字符：/ -> _, : -> -
          safe_image_tag=$(echo "$image_tag" | sed 's|/|_|g')  # 标签中的/也替换为_
          
          # 生成最终镜像名称（确保唯一性）
          final_image="${converted_name}-${safe_image_tag}"  # 格式：镜像名-标签
          
          # 处理多平台镜像（构建跨平台支持）
          if [ -n "$platform_arg" ]; then
            platform_suffix="-$(echo "$platform_arg" | tr '/' '_')"  # linux/amd64 -> linux_amd64
            final_image="${final_image}${platform_suffix}"  # 追加平台后缀
          fi

          # 生成合法目标路径（遵循Docker镜像规范）
          target_image="${TARGET_PREFIX}:${final_image}"  # 最终格式：registry/namespace:name-tag-platform

          echo "====== 处理镜像：$src_image => $target_image ======"
          
          # 拉取源镜像（确保镜像存在）
          docker pull "$src_image"  # 从Docker Hub拉取官方镜像
          
          # 重新打标签（建立与目标仓库的关联）
          docker tag "$src_image" "$target_image"  # 创建符合阿里云规范的标签
          
          # 推送镜像到阿里云（核心操作）
          docker push "$target_image"  # 上传镜像到指定仓库
          
          # 清理本地镜像（节省磁盘空间）
          docker rmi "$src_image" "$target_image" || true  # 忽略可能的删除错误

        done < ./images.txt  # 从当前目录读取镜像列表

    # ========== 4. 清理阶段（资源回收） ==========
    - name: Cleanup
      run: docker system prune -af  # 清理所有未使用的Docker对象
      # 知识点：-a 删除所有未使用的镜像，-f 强制删除不提示
